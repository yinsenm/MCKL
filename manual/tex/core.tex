% ============================================================================
%  MCKL/manual/tex/core.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2017, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Building Blocks}
\label{chap:Building Blocks}

In this chapter, we introduce the basic building blocks of the library.

\section{Iterators}
\label{sec:Iterators}

\subsection{Step Iterator}
\label{sub:Step Iterator}

The step iterator can be used to access memory in a regular, non-contiguous
pattern. The class template,
\begin{verbatim}
template <typename Base>
class StepIterator;
\end{verbatim}
implements an iterator adapter, that will increment a base iterator multiple
steps at a time. It can be constructed by,
\begin{verbatim}
StepIterator(Base base = Base(), difference_type step = 1);
\end{verbatim}
All operations for a random access iterator is defined. For example,
\begin{verbatim}
Base base;
StepIterator<Base> iter(base, step);
*iter;    // => *base
++iter;   // => std::advance(base, step);
--iter;   // => std::advance(base, -step);
iter + n; // => std::advance(base, step * n);
iter[n];  // => *(iter + n);
\end{verbatim}
The base iterator needs to meet the input iterator requirement for most
operations. If it is to be decremented, either through subtraction or negative
step size, it also needs to meet the bidirectional iterator requirement as
well.

\subsection{Range}
\label{sub:Range}

The range concept abstracts a half-open interval $[b, e)$ denoted by either a
pair of integers or iterators. This is implemented by the following class
template,
\begin{verbatim}
template <typename T, bool = std::is_integral<T>::value>
class Range;
\end{verbatim}
A range can be constructed by,
\begin{verbatim}
Range(T begin, T end, size_type grainsize = 1);
\end{verbatim}
The lower and upper bounds of the interval, and the grain size, can be access
later,
\begin{verbatim}
Range(begin, end, grainsize) range;
range.begin();
range.end();
range.grainsize();
\end{verbatim}
When |T| is of an iterator type, the interval can be mapped into one denoted by
a pair of integers. Thus, we will use the integer denoted interval $[b, e)$ for
the discussions follows.

A range can be split into two, $[b, h)$ and $[h, e)$ such that $h = \Floor{(b +
  e) / 2}$. Such the two ranges can be created by the following constructor,
\begin{verbatim}
template <typename Split>
Range(Range &other, Split);
\end{verbatim}
where |Split| can be any type. Its sole purpose is to distinguish this
constructor from the copy constructor. A range is empty if and only if $b \ge
e$. This can be tested by the |empty| method. The size of the range is
$\max\Curly{0, e - b}$, which is returned by the |size| method. A range is
divisible if its grain size is smaller than or equal to its size, where the
grain size is specified by the optional third parameter of the constructor.
This can be tested by the |is_divisible| method.

\section{Matrix}
\label{sec:Matrix}

The class template,
\begin{verbatim}
template <MatrixLayout Layout, typename T>
clas Matrix;
\end{verbatim}
is a container representing a two-dimensional array. The enumerator
|MatrixLayout| is defined as the following
\begin{verbatim}
enum class MatrixLayout { RowMajor = 101, ColMajor = 102 };
\end{verbatim}
For convenience, two constants are defined,
\begin{verbatim}
constexpr MatrixLayout RowMajor = MatrixLayout::RowMajor;
constexpr MatrixLayout ColMajor = MatrixLayout::ColMajor;
\end{verbatim}

A matrix can be constructed with either zero elements or the numbers of rows
and columns.
\begin{verbatim}
Matrix<RowMajor, double> A;       // An empty matrix
Matrix<RowMajor, double> A(n, m); // An n by m matrix
\end{verbatim}
A few attributes of the matrix can be accessed,
\begin{verbatim}
A.nrow(); // Number of rows n
A.ncol(); // Number of columns m
\end{verbatim}
The size of the matrix can be changed,
\begin{verbatim}
A.resize(n, m); // Change the number of rows and columns
\end{verbatim}
Let $p$ and $q$ be the number of rows and columns of the original matrix,
respectively. Let $s$ and $t$ be the new dimensions, and $n = \min\Curly{p, s}$
and $m = \min\Curly{q, t}$. Then the $n$ by $m$ upper-left corner of the
original matrix is preserved. There are few ways to access elements,
\begin{verbatim}
A(i, j);    // The element of i-th row and j-th column
A.at(i, j); // The same but with assertions
\end{verbatim}
It is possible to access the memory buffer directly,
\begin{verbatim}
A.data();       // => &A(0, 0);
A.row_stride(); // => &A(0, 1) - &A(0, 0);
A.row_data(i);  // => &A(i, 0);
A.col_stride(); // => &A(1, 0) - &A(0, 0);
A.col_data(j);  // => &A(0, j);
\end{verbatim}
The concept of ``stride'' is important when iterating elements through the
|row_data| and |col_data|. Depending on the template parameter |Layout|, a
matrix may have either unit stride row-wise or column-wise.

Other methods such as |reserve|, |swap|, etc., take their usual meanings as in
the standard library containers.

In additional, |Matrix| also provide iterator based element access.
\begin{verbatim}
A.begin();      // => The upper left corner of the matrix
A.end();        // => One pass the lower right corner of the matrix
A.row_begin(i); // => Beginning of the i-th row
A.row_end(i);   // => End of the i-th row
A.col_begin(j); // => Beginning of the j-th column
A.col_end(j);   // => End of the j-th column
\end{verbatim}

\subsection{Matrix of States}
\label{sub:Matrix of States}

Consider a collection of samples $X_{1:N}$ and each $X_i$ is a $d$-vector. In
this case, it can be conveniently represented by an $N$ by $d$ matrix. The
dimension $d$ (the number of columns) of this matrix is usually fixed and often
known at compile time, while the sample size $N$ (the number of rows) may
change as an algorithm proceeds. A derived class of |Matrix| is defined for
this purpose.
\begin{verbatim}
template <MatrixLayout Layout, std::size_t Dim, typename T>
class StateMatrix : public Matrix<Layout, T>;
\end{verbatim}
If the template parameter |Dim| denotes the dimension $d$. If it is zero, then
the dimension can be later changed at compile time. Otherwise, it is fixed.
Such a matrix can be constructed given it sample size,
\begin{verbatim}
StateMatrix<RowMajor, 4, double> S(n); // An n by 4 matrix
\end{verbatim}
It can also be constructed given the sampler size and dimension,
\begin{verbatim}
StateMatrix<RowMajor, 0, double> S(n, d); // An n by d matrix
\end{verbatim}
Note that, the constructor above is only available if |Dim| is zero. A few
attributes of the matrix can be access,
\begin{verbatim}
S.size(); // => S.nrow();
S.dim();  // => S.ncol();
\end{verbatim}
A few methods are given new overloads over the base class, which may be more
convenient when the matrix is used in this context,
\begin{verbatim}
S.resize(n); // => S.resize(n, S.ncol());
S.reserve(n);
\end{verbatim}

\section{State}
\label{sec:State}

\section{Weight}
\label{sec:Weight}

\section{Particle}
\label{sec:Particle}

\section{Estimator}
\label{sec:Estimator}
