% ============================================================================
%  MCKL/manual/tex/core.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2017, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Building blocks}
\label{chap:Building blocks}

In this chapter, we introduce the basic data structures and other building
blocks of the library.

\section{Matrix}
\label{sec:Matrix}

The |Matrix| class is a container representing a two-dimensional array. It is
not designed to be a full-fledged matrix class for the purposes such as linear
algebra. Instead, it will serve as the base class later for some data
structures with matrix-like data layout.

The class is declared as the following,
\begin{verbatim}
template <MatrixLayout Layout, typename T>
clas Matrix;
\end{verbatim}
where |MatrixLayout| is an enumeration defined as the following
\begin{verbatim}
enum class MatrixLayout { RowMajor = 101, ColMajor = 102 };
\end{verbatim}
and |T| is the data type of the matrix element. For convenience, two constants
are defined,
\begin{verbatim}
constexpr MatrixLayout RowMajor = MatrixLayout::RowMajor;
constexpr MatrixLayout ColMajor = MatrixLayout::ColMajor;
\end{verbatim}

A matrix can be constructed with either zero elements or the number of rows and
columns.
\begin{verbatim}
Matrix<RowMajor, double> A;       // An empty matrix
Matrix<RowMajor, double> A(n, m); // An n by m matrix
\end{verbatim}
A few attributes of the matrix can be accessed,
\begin{verbatim}
A.nrow(); // Number of rows n
A.ncol(); // Number of columns m
\end{verbatim}
The size of the matrix can be changed,
\begin{verbatim}
A.resize(n, m); // Change the number of rows and columns
\end{verbatim}
Let $p$ and $q$ be the number of rows and columns of the original matrix,
respectively. Let $s$ and $t$ be the new dimensions, and $n = \min\Curly{p, s}$
and $m = \min\Curly{q, t}$. Then the $n$ by $m$ upper-left corner of the
original matrix is preserved. There are few ways to access elements,
\begin{verbatim}
A(i, j);    // The element of i-th row and j-th column
A.at(i, j); // The same but with assertions
\end{verbatim}
It is possible to access the memory buffer directly,
\begin{verbatim}
A.data();       // => &A(0, 0);
A.row_stride(); // => &A(0, 1) - &A(0, 0);
A.row_data(i);  // => &A(i, 0);
A.col_stride(); // => &A(1, 0) - &A(0, 0);
A.col_data(j);  // => &A(0, j);
\end{verbatim}
The concept of ``stride'' is important when iterating elements through the
|row_data| and |col_data|. Depending on the template parameter |Layout|, a
matrix may have either unit stride row-wise or column-wise.

Other methods such as |reserve|, |swap|, etc., take their usual meanings as in
the standard library containers. See the reference manual for details.

\subsection{Matrix of states}
\label{sub:Matrix of states}

Consider a collection of samples $X_{1:N}$ and each $X_i$ is a $d$-vector. In
this case, it can be conveniently represented by an $N$ by $d$ matrix. The
dimension $d$ (number of columns) of this matrix is usually fixed and often
known at compile time, while the sample size $N$ (number of rows) may change as
an algorithm proceeds. A derived class of |Matrix| is defined for this purpose.
\begin{verbatim}
template <MatrixLayout Layout, std::size_t Dim, typename T>
class StateMatrix : public Matrix<Layout, T>;
\end{verbatim}
If the template parameter |Dim| denotes the dimension $d$. If it is zero, then
the dimension can be later changed at compile time. Otherwise, it is fixed.
Such a matrix can be constructed given it sample size,
\begin{verbatim}
StateMatrix<RowMajor, 4, double> S(n); // And n by 4 matrix of states
\end{verbatim}
It can also be constructed given the sampler size and dimension,
\begin{verbatim}
StateMatrix<RowMajor, 0, double> S(n, d); // And n by d matrix of states
\end{verbatim}
Note that, the constructor above is only available if |Dim| is zero. A few
attributes of the matrix can be access,
\begin{verbatim}
S.size(); // => S.nrow();
S.dim();  // => S.ncol();
\end{verbatim}
A few methods are given new overloads over the base class, which may be more
convenient when the matrix is used in this context,
\begin{verbatim}
S.resize(n); // => S.resize(n, S.ncol());
S.reserve(n);
\end{verbatim}

\subsection{Matrix of estimates}
\label{sub:Matrix of estimates}

\section{Weight}
\label{sec:Weight}

\section{Particle system}
\label{sec:Particle system}

\section{Estimator of iterative algorithms}
\label{sec:Estimator of iterative algorithms}
