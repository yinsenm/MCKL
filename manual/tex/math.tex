% ============================================================================
%  MCKL/manual/tex/math.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2017, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Mathematical Functions}
\label{chap:Mathemtical Functions}

\section{Constants}
\label{sec:Constants}

\mckl defines some mathematical constants in the form of constant expression
functions. For example, to get the value of $\pi$ with a desired precision, one
can use the following,
\begin{verbatim}
constexpr float       pi_f = const_pi<float>();
constexpr double      pi_d = const_pi<double>();
constexpr long double pi_l = const_pi<long double>();
\end{verbatim}
The compiler evaluates these values at compile-time and thus there is no
performance difference from hard-coding the constants in the program, while the
readability is improved. All defined constants are listed in
table~\ref{tab:Mathematical constants}.

\begin{table}
  \begin{tabularx}{\textwidth}{p{1.5in}Lp{1.5in}L}
    \toprule
    Function & Value & Function & Value \\
    \midrule
    \texttt{const\_inf}            & $\infty$        &
    \texttt{const\_nan}            & NaN             \\
    \texttt{const\_zero}           & $0$             &
    \texttt{const\_one}            & $1$             \\
    \texttt{const\_pi}             & $\pi$           &
    \texttt{const\_pi\_2}          & $2\pi$          \\
    \texttt{const\_pi\_inv}        & $1/\pi$         &
    \texttt{const\_pi\_sqr}        & $\pi^2$         \\
    \texttt{const\_pi\_by2}        & $\pi/2$         &
    \texttt{const\_pi\_by3}        & $\pi/3$         \\
    \texttt{const\_pi\_by4}        & $\pi/4$         &
    \texttt{const\_pi\_by6}        & $\pi/6$         \\
    \texttt{const\_pi\_2by3}       & $2\pi/3$        &
    \texttt{const\_pi\_3by4}       & $3\pi/4$        \\
    \texttt{const\_pi\_4by3}       & $4\pi/3$        &
    \texttt{const\_sqrt\_pi}       & $\sqrt{\pi}$    \\
    \texttt{const\_sqrt\_pi\_2}    & $\sqrt{2\pi}$   &
    \texttt{const\_sqrt\_pi\_inv}  & $\sqrt{1/\pi}$  \\
    \texttt{const\_sqrt\_pi\_by2}  & $\sqrt{\pi/2}$  &
    \texttt{const\_sqrt\_pi\_by3}  & $\sqrt{\pi/3}$  \\
    \texttt{const\_sqrt\_pi\_by4}  & $\sqrt{\pi/4}$  &
    \texttt{const\_sqrt\_pi\_by6}  & $\sqrt{\pi/6}$  \\
    \texttt{const\_sqrt\_pi\_2by3} & $\sqrt{2\pi/3}$ &
    \texttt{const\_sqrt\_pi\_3by4} & $\sqrt{3\pi/4}$ \\
    \texttt{const\_sqrt\_pi\_4by3} & $\sqrt{4\pi/3}$ &
    \texttt{const\_ln\_pi}         & $\ln{\pi}$      \\
    \texttt{const\_ln\_pi\_2}      & $\ln{2\pi}$     &
    \texttt{const\_ln\_pi\_inv}    & $\ln{1/\pi}$    \\
    \texttt{const\_ln\_pi\_by2}    & $\ln{\pi/2}$    &
    \texttt{const\_ln\_pi\_by3}    & $\ln{\pi/3}$    \\
    \texttt{const\_ln\_pi\_by4}    & $\ln{\pi/4}$    &
    \texttt{const\_ln\_pi\_by6}    & $\ln{\pi/6}$    \\
    \texttt{const\_ln\_pi\_2by3}   & $\ln{2\pi/3}$   &
    \texttt{const\_ln\_pi\_3by4}   & $\ln{3\pi/4}$   \\
    \texttt{const\_ln\_pi\_4by3}   & $\ln{4\pi/3}$   &
    \texttt{const\_e}              & $\EE$           \\
    \texttt{const\_e\_inv}         & $1/\EE$         &
    \texttt{const\_sqrt\_e}        & $\sqrt{\EE}$    \\
    \texttt{const\_sqrt\_e\_inv}   & $\sqrt{1/\EE}$  &
    \texttt{const\_sqrt\_2}        & $\sqrt{2}$      \\
    \texttt{const\_sqrt\_3}        & $\sqrt{3}$      &
    \texttt{const\_sqrt\_5}        & $\sqrt{5}$      \\
    \texttt{const\_sqrt\_10}       & $\sqrt{10}$     &
    \texttt{const\_sqrt\_1by2}     & $\sqrt{1/2}$    \\
    \texttt{const\_sqrt\_1by3}     & $\sqrt{1/3}$    &
    \texttt{const\_sqrt\_1by5}     & $\sqrt{1/5}$    \\
    \texttt{const\_sqrt\_1by10}    & $\sqrt{1/10}$   &
    \texttt{const\_ln\_2}          & $\ln{2}$        \\
    \texttt{const\_ln\_3}          & $\ln{3}$        &
    \texttt{const\_ln\_5}          & $\ln{5}$        \\
    \texttt{const\_ln\_10}         & $\ln{10}$       &
    \texttt{const\_ln\_inv\_2}     & $1/\ln{2}$      \\
    \texttt{const\_ln\_inv\_3}     & $1/\ln{3}$      &
    \texttt{const\_ln\_inv\_5}     & $1/\ln{5}$      \\
    \texttt{const\_ln\_inv\_10}    & $1/\ln{10}$     &
    \texttt{const\_ln\_ln\_2}      & $\ln\ln{2}$     \\
    \bottomrule
  \end{tabularx}
  \caption{Mathematical constants}
  \label{tab:Mathematical constants}
\end{table}

\clearpage

\section{Vectorized Functions}
\label{sec:Vectorized Functions}

\mckl provides a set of vectorized elementary mathematical functions. For
example, to perform additions of two vectors,
\begin{verbatim}
size_t n = 1000;
Vector<double> a(n), b(n), y(n);
// Fill vectors a and b
add(n, a.data(), b.data(), y.data());
\end{verbatim}
This is equivalent to,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    y[i] = a[i] + b[i];
\end{verbatim}
The functions defined are listed in tables~\ref{tab:Arithmetic functions}
to~\ref{tab:Rounding functions}. For each function, the first parameter is
always the length of the vector, and the last is a pointer to the output vector
(except for |sincos| and |modf|, which have two output vecrors). The output
parameters are always vectors. Some of the input parameters may be scalars. For
example, in the function call,
\begin{verbatim}
muladd(n, a, b, c, y);
\end{verbatim}
in table~\ref{tab:Arithmetic functions}, the input parameters are |a|, |b|, and
|c|. Some of them, (but not all), can be scalars instead of pointers to
vectors. The output parameter |y| has to be a pointer to a vector. Therefore,
there are seven versions of this function for each type of the parameters.

The input of these functions can be either real numbers (floating point types),
or complex numbers (|std::complex<double>|, etc.), or both. The supported data
types are also listed in the tables. In most cases, output data type is the
same as the input. There are a few exceptions. The |abs| and |arg| functions
always have real numbers as output. The |cis| function takes real numbers as
input and complex numbers as output. Note that, mixed precision is not allowed.
For example,
\begin{verbatim}
Vector<double> a(n);
Vector<double> b(n);
Vector<double> y(n);
muladd(n, a.data(), b.data(), 2, y.data());
\end{verbatim}
causes compile-time error because the fourth argument is an integer while the
others are floating point types. The correct call shall be,
\begin{verbatim}
muladd(n, a.data(), b.data(), 2.0, y.data());
\end{verbatim}
The same principle applies to mixed types functions (|abs|, |arg| and |cis|).

With only the standard library, these functions do not provide performance
advantage compared to simple loops. When \mkl \vml is available, some functions
can have substantial performance improvement when all input arguments are
vectors of types single or double precision floating point types, or their
complex counterparts. The performance of vectorized random number generating
(see section~\ref{sec:Vectorized Random Number Generating}) heavily depends on
these functions.

The input and output pointers are allowed to alias to each other in the sense
that they might pointing to the same memory locations. However, if they point
different locations but the vectors overlap, the behavior is undefined.

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{add}       & $y = a + b$           & Real, Complex \\
    \texttt{sub}       & $y = a - b$           & Real, Complex \\
    \texttt{sqr}       & $y = a^2$             & Real          \\
    \texttt{mul}       & $y = ab$              & Real, Complex \\
    \texttt{mulbyconj} & $y = a\bar{b}$        & Complex       \\
    \texttt{conj}      & $y = \bar{a}$         & Complex       \\
    \texttt{abs}       & $y = \Abs{a}$         & Real, Complex \\
    \texttt{arg}       & $y = \mathrm{arg}(a)$ & Complex       \\
    \texttt{muladd}    & $y = ab + c$          & Real, Complex \\
    \texttt{mulsub}    & $y = ab - c$          & Real, Complex \\
    \texttt{nmuladd}   & $y = -ab + c$         & Real, Complex \\
    \texttt{nmulsub}   & $y = -ab - c$         & Real, Complex \\
    \texttt{fmadd}     & $y = ab + c$ (fused)  & Real          \\
    \texttt{fmsub}     & $y = ab - c$ (fused)  & Real          \\
    \texttt{fnmadd}    & $y = -ab + c$ (fused) & Real          \\
    \texttt{fnmsub}    & $y = -ab - c$ (fused) & Real          \\
    \bottomrule
  \end{tabularx}
  \caption{Arithmetic functions}
  \label{tab:Arithmetic functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{inv}     & $y = 1 / a$            & Real          \\
    \texttt{div}     & $y = a / b$            & Real, Complex \\
    \texttt{sqrt}    & $y = \sqrt{a}$         & Real, Complex \\
    \texttt{invsqrt} & $y = 1 / \sqrt{a}$     & Real          \\
    \texttt{cbrt}    & $y = a^{1/3}$          & Real          \\
    \texttt{invcbrt} & $y = a^{-1/3}$         & Real          \\
    \texttt{pow2o3}  & $y = a^{2/3}$          & Real          \\
    \texttt{pow3o2}  & $y = a^{3/2}$          & Real          \\
    \texttt{pow}     & $y = a^b$              & Real, Complex \\
    \texttt{hypot}   & $y = \sqrt{a^2 + b^2}$ & Real          \\
    \bottomrule
  \end{tabularx}
  \caption{Power and root functions}
  \label{tab:Power and root functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{exp}   & $y = \EE^a$       & Real, Complex \\
    \texttt{exp2}  & $y = 2^a$         & Real          \\
    \texttt{expm1} & $y = \EE^a - 1$   & Real          \\
    \texttt{log}   & $y = \ln a$       & Real, Complex \\
    \texttt{log2}  & $y = \log_2 a$    & Real          \\
    \texttt{log10} & $y = \log_{10} a$ & Real, Complex \\
    \texttt{log1p} & $y = \ln(a + 1)$  & Real          \\
    \bottomrule
  \end{tabularx}
  \caption{Exponential and logarithm functions}
  \label{tab:Exponential and logarithm functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{cos}    & $y = \cos(a)$        & Real, Complex \\
    \texttt{sin}    & $y = \sin(a)$        & Real, Complex \\
    \texttt{sincos} & $y = \sin(a)$, $z = \cos(a)$ & Real  \\
    \texttt{cis}    & $y = \cos(a) + i\sin(a)$   & Complex \\
    \texttt{tan}    & $y = \tan(a)$        & Real, Complex \\
    \texttt{acos}   & $y = \arccos(a)$     & Real, Complex \\
    \texttt{asin}   & $y = \arcsin(a)$     & Real, Complex \\
    \texttt{atan}   & $y = \arctan(a)$     & Real, Complex \\
    \texttt{atan2}  & $y = \arctan(a / b)$ & Real          \\
    \bottomrule
  \end{tabularx}
  \caption{Trigonometric functions}
  \label{tab:Trigonometric functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{cosh}  & $y = \cosh(a)$             & Real, Complex \\
    \texttt{sinh}  & $y = \sinh(a)$             & Real, Complex \\
    \texttt{tanh}  & $y = \tanh(a)$             & Real, Complex \\
    \texttt{acosh} & $y = \mathrm{arc}\cosh(a)$ & Real, Complex \\
    \texttt{asinh} & $y = \mathrm{arc}\sinh(a)$ & Real, Complex \\
    \texttt{atanh} & $y = \mathrm{arc}\tanh(a)$ & Real, Complex \\
    \bottomrule
  \end{tabularx}
  \caption{Hyperbolic functions}
  \label{tab:Hyperbolic functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{erf}     & $y = \mathrm{erf}(a)$  & Real \\
    \texttt{erfc}    & $y = \mathrm{erfc}(a)$ & Real \\
    \texttt{cdfnorm} & $y = (1 + \mathrm{erf}(a / \sqrt{2})) / 2$ & Real \\
    \texttt{lgamma}  & $y = \ln\Gamma(a)$     & Real \\
    \texttt{tgamma}  & $y = \Gamma(a)$        & Real \\
    \bottomrule
  \end{tabularx}
  \caption{Special functions}
  \label{tab:Special functions}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LLC}
    \toprule
    Function & Operation & Data type \\
    \midrule
    \texttt{floor} & $y = \Floor{a}$                       & Real \\
    \texttt{ceil}  & $y = \Ceil{a}$                        & Real \\
    \texttt{trunc} & $y = \mathrm{sgn}(a)\Floor{\Abs{a}}$  & Real \\
    \texttt{round} & $y = \text{nearest integer of }a$     & Real \\
    \texttt{nearbyint} & $y = \text{nearest integer of }a$ & Real \\
    \texttt{rint}  & $y = \text{nearest integer of }a$     & Real \\
    \texttt{modf}&$y = \mathrm{sign}(a)\Floor{\Abs{a}}$, $z = a - y$ & Real \\
    \bottomrule
  \end{tabularx}
  \caption{Rounding functions}
  \label{tab:Rounding functions}
\end{table}

\clearpage

\section{Fused Multiplication and Addition}
\label{sec:Fused Multiplication and Addition}

The |muladd| and |fmadd| functions in the last section differs in that |fmadd|
always does fused multiplication and addition by |std::fma| while |muladd| use
one multiplication and one addition. However, the compiler may or may not be
able to make use the platform \fma support. And it may not vectorize the loop
in |fmadd| etc., as most modern \cpp compilers would do for simpler operations
such as addition and multiplication.

When software implementation of |std::fma| is used, it will be much slower than
using one multiplication and one addition. In this case, there are assembly
implementations that take advantage of the platform support for single and
double precision. To enable this feature, one need to build and link to the
optional runtime library (see section~\ref{sec:Optional Runtime Library}). One
also need to set the configuration macro |MCKL_USE_ASM_LIB| to true. In
addition, this feature is only enabled for platforms with \fma{}3 instruction
set support.

The library detects the availability of these instructions using compiler
macros. If this mechanism is not adequate, one can manually enable or disable
them using the configuration macro |MCKL_HAS_FMA|. Note that, when the compiler
is able to generate vectorized loop for |std::fma|, the assembly library may or
may not outperform the compiler generated binary. If the compiler generated
binary is preferred but the runtime library is also enabled for its other
features, then one can define the configuration macro |MCKL_USE_ASM_FMA| to
false to disable this feature.

The same principles also applies to other related functions such as |mulsub|
and |fmsub|. Last but not least, when the runtime library is used, it also
replace single and double precisions of |muladd|, etc., with their
corresponding fused version.

\section{Experimental Vectorized Implementation}
\label{sec:Experimental Vectorized Implementation}

Optionally, one can enable experimental implementations of a few selected
functions, listed in table~\ref{tab:Functions with experimental vectorized
implementation}, to enhance their performance of double precision. The
exponential, logarithm and related functions also enhance performance of single
precision. To enable this feature, one needs to build and link to the optional
runtime library (see section~\ref{sec:Optional Runtime Library}). One also
needs to set the following configuration macros to true,
\begin{verbatim}
#define MCKL_USE_ASM_LIB 1
#define MCKL_USE_ASM_VMF 1
\end{verbatim}
In addition, this feature is only enabled for platforms with \avx{}2 and
\fma{}3 instruction sets support. The library detects the availability of these
instructions using compiler macros. If this mechanism is inadequate, one can
manually enable or disable them using the configuration macros, |MCKL_HAS_AVX2|
and |MCKL_HAS_FMA|, respectively.

\subsection{Caveats}
\label{sub:Caveats}

The three exponential functions have slightly reduced upper bounds of ranges.
The four trigonometric functions have reduced ranges. They only give meaningful
results for input $\Abs{a} < A$ where $A \approx 2^{30.5}$. For finite values
with larger magnitudes, finite results will be given but the accuracy
degenerate quickly. For $A < \Abs{a} < 2^{43}$, there are at least three
accurate decimal digits. For values with even larger magnitudes, the results
are useless.

\subsection{Subnormal Numbers}
\label{sub:Subnormal Numbers}

Positive subnormal inputs for |log|, |log2| and |log10| will give $-\infty$ as
results. Subnormal inputs for |exp| and |exp2| will give $0$ as results. For
other functions, subnormal inputs are treated the same way as normal numbers.

\subsection{Special Values}
\label{sub:Special Values}

The handling of special values, $-0.0$, $0.0$, $-\infty$, $\infty$, \nan,
underflows, and overflows follows the \ieee~754 standard, except for the
treatment of subnormal numbers.

\subsection{Measured Accuracy}
\label{sub:Measured Accuracy}

These functions have reduced accuracy compared to the standard library.
Reputable implementations of math functions usually give results with error
bounded by 1~\ulp. Some of these functions, especially the trigonometric
functions, give larger errors. Tables~\ref{tab:Measured accuracy of vectorized
  implementation of exp} to~\ref{tab:Measured accuracy of vectorized
implementation of tan} give the measured upper bounds of errors and the
intervals on which they are measured. The measurement was done by generating
one billion random inputs. In the tables, $\delta$ denotes the smallest normal
floating point numbers for the respective precision.

\begin{table}
  \def\check{\char"2713}
  \begin{tabularx}{\textwidth}{LCC}
    \toprule
    Function & Single precision & Double precision \\
    \midrule
    \texttt{exp}    & \check & \check \\
    \texttt{exp2}   & \check & \check \\
    \texttt{expm1}  & \check & \check \\
    \texttt{log}    & \check & \check \\
    \texttt{log2}   & \check & \check \\
    \texttt{log10}  & \check & \check \\
    \texttt{log1p}  & \check & \check \\
    \texttt{cos}    &        & \check \\
    \texttt{sin}    &        & \check \\
    \texttt{sincos} &        & \check \\
    \texttt{tan}    &        & \check \\
    \bottomrule
  \end{tabularx}
  \caption{Functions with experimental vectorized implementation}
  \label{tab:Functions with experimental vectorized implementation}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[-87.3, -87)$      & $1$ & $[-708.4, -707)$    & $1$ \\
    $[-87, -70)$        & $1$ & $[-707, -500)$      & $1$ \\
    $[-70, -1)$         & $1$ & $[-500, -1)$        & $1$ \\
    $[-1, -\delta)$     & $1$ & $[-1, -\delta)$     & $1$ \\
    $[-\delta, \delta)$ & $0$ & $[-\delta, \delta)$ & $0$ \\
    $[\delta, 1)$       & $1$ & $[\delta, 1)$       & $1$ \\
    $[1, 70)$           & $1$ & $[1, 500)$          & $1$ \\
    $[70, 87)$          & $1$ & $[500, 707)$        & $1$ \\
    $[87, 88.4)$        & $1$ & $[707, 709.4)$      & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{exp}}
  \label{tab:Measured accuracy of vectorized implementation of exp}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[-126, -100)$      & $1$ & $[-1022, -1000)$    & $1$ \\
    $[-100, -50)$       & $1$ & $[-1000, -500)$     & $1$ \\
    $[-50, -1)$         & $1$ & $[-500, -1)$        & $1$ \\
    $[-1, -\delta)$     & $1$ & $[-1, -\delta)$     & $1$ \\
    $[-\delta, \delta)$ & $0$ & $[-\delta, \delta)$ & $0$ \\
    $[\delta, 1)$       & $1$ & $[\delta, 1)$       & $1$ \\
    $[1, 50)$           & $1$ & $[1, 500)$          & $1$ \\
    $[50, 100)$         & $1$ & $[500, 1000)$       & $1$ \\
    $[100, 127)$        & $1$ & $[1000, 1023)$      & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{exp2}}
  \label{tab:Measured accuracy of vectorized implementation of exp2}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[-87.3, -87)$           & $0$ & $[-708.4, -707)$         & $0$ \\
    $[-87, -70)$             & $0$ & $[-707, -500)$           & $0$ \\
    $[-70, -1)$              & $1$ & $[-500, -1)$             & $1$ \\
    $[-1, -\ln(2))$          & $1$ & $[-1, -\ln(2))$          & $1$ \\
    $[-\ln(2), -\ln(2) / 2)$ & $2$ & $[-\ln(2), -\ln(2) / 2)$ & $2$ \\
    $[-\ln(2) / 2, -\delta)$ & $2$ & $[-\ln(2) / 2, -\delta)$ & $1$ \\
    $[-\delta, \delta)$      & $0$ & $[-\delta, \delta)$      & $0$ \\
    $[\delta, \ln(2) / 2)$   & $1$ & $[\delta, \ln(2) / 2)$   & $1$ \\
    $[\ln(2) / 2, \ln(2))$   & $2$ & $[\ln(2) / 2, \ln(2))$   & $2$ \\
    $[\ln(2), 1)$            & $1$ & $[\ln(2), 1)$            & $1$ \\
    $[1, 70)$                & $2$ & $[1, 500)$               & $1$ \\
    $[70, 87)$               & $1$ & $[500, 707)$             & $1$ \\
    $[87, 88.4)$             & $1$ & $[707, 709.44)$          & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{expm1}}
  \label{tab:Measured accuracy of vectorized implementation of expm1}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[\delta, \sqrt{2} / 2)$   & $1$ & $[\delta, \sqrt{2} / 2)$   & $1$ \\
    $[\sqrt{2} / 2, \sqrt{2})$ & $1$ & $[\sqrt{2} / 2, \sqrt{2})$ & $1$ \\
    $[\sqrt{2}, 10)$           & $1$ & $[\sqrt{2}, 10)$           & $1$ \\
    $[10, 10^2)$               & $1$ & $[10, 10^2)$               & $1$ \\
    $[10^2, 10^3)$             & $1$ & $[10^2, 10^3)$             & $1$ \\
    $[10^3, 10^4)$             & $1$ & $[10^3, 10^4)$             & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{log}}
  \label{tab:Measured accuracy of vectorized implementation of log}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[\delta, \sqrt{2} / 2)$  & $1$ & $[\delta, \sqrt{2} / 2)$  & $1$ \\
    $[\sqrt{2} / 2, sqrt{2})$ & $2$ & $[\sqrt{2} / 2, sqrt{2})$ & $2$ \\
    $[\sqrt{2}, 10)$          & $1$ & $[\sqrt{2}, 10)$          & $1$ \\
    $[10, 10^2)$              & $1$ & $[10, 10^2)$              & $1$ \\
    $[10^2, 10^3)$            & $1$ & $[10^2, 10^3)$            & $1$ \\
    $[10^3, 10^4)$            & $1$ & $[10^3, 10^4)$            & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{log2}}
  \label{tab:Measured accuracy of vectorized implementation of log2}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[\delta, \sqrt{2} / 2)$  & $2$ & $[\delta, \sqrt{2} / 2)$  & $1$ \\
    $[\sqrt{2} / 2, sqrt{2})$ & $2$ & $[\sqrt{2} / 2, sqrt{2})$ & $2$ \\
    $[\sqrt{2}, 10)$          & $2$ & $[\sqrt{2}, 10)$          & $1$ \\
    $[10, 10^2)$              & $2$ & $[10, 10^2)$              & $1$ \\
    $[10^2, 10^3)$            & $1$ & $[10^2, 10^3)$            & $1$ \\
    $[10^3, 10^4)$            & $1$ & $[10^3, 10^4)$            & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{log10}}
  \label{tab:Measured accuracy of vectorized implementation of log10}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LcLc}
    \toprule
    \multicolumn{2}{c}{Single precision} &
    \multicolumn{2}{c}{Double precision} \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    Range & Error (\ulp) & Range & Error (\ulp) \\
    \cmidrule(lr){1-2}\cmidrule(lr){3-4}
    $[-1, \sqrt{2} / 2 - 1)$  & $2$ & $[-1, \sqrt{2} / 2 - 1)$      & $3$ \\
    $[\sqrt{2}/2-1, -\delta)$ & $1$ & $[\sqrt{2} / 2 - 1, -\delta)$ & $1$ \\
    $[-\delta, \delta)$       & $0$ & $[-\delta, \delta)$           & $0$ \\
    $[\delta, \sqrt{2} - 1)$  & $1$ & $[\delta, \sqrt{2} - 1)$      & $1$ \\
    $[\sqrt{2} - 1, 1)$       & $2$ & $[\sqrt{2} - 1, 1)$           & $2$ \\
    $[1, 10)$                 & $2$ & $[1, 10)$                     & $2$ \\
    $[10, 10^2)$              & $1$ & $[10, 10^2)$                  & $1$ \\
    $[10^2, 10^3)$            & $1$ & $[10^2, 10^3)$                & $1$ \\
    $[10^3, 10^4)$            & $1$ & $[10^3, 10^4)$                & $1$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{log1p}}
  \label{tab:Measured accuracy of vectorized implementation of log1p}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LC}
    \toprule
    Range & Error (\ulp, double precision only) \\
    \midrule
    $[-1.7\times10^9, -1)$ & $2$ \\
    $[-1, -\delta)$        & $2$ \\
    $[-\delta, \delta)$    & $0$ \\
    $[\delta, 1)$          & $2$ \\
    $[1, 1.7\times10^9)$   & $2$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{cos}}
  \label{tab:Measured accuracy of vectorized implementation of cos}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LC}
    \toprule
    Range & Error (\ulp, double precision only) \\
    \midrule
    $[-1.7\times10^9, -1)$ & $2$ \\
    $[-1, -\delta)$        & $2$ \\
    $[-\delta, \delta)$    & $0$ \\
    $[\delta, 1)$          & $2$ \\
    $[1, 1.7\times10^9)$   & $2$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{sin}}
  \label{tab:Measured accuracy of vectorized implementation of sin}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LC}
    \toprule
    Range & Error (\ulp, double precision only) \\
    \midrule
    $[-1.7\times10^9, -1)$ & $2$ \\
    $[-1, -\delta)$        & $2$ \\
    $[-\delta, \delta)$    & $0$ \\
    $[\delta, 1)$          & $2$ \\
    $[1, 1.7\times10^9)$   & $2$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{sincos}}
  \label{tab:Measured accuracy of vectorized implementation of sincos}
\end{table}

\begin{table}
  \begin{tabularx}{\textwidth}{LC}
    \toprule
    Range & Error (\ulp, double precision only) \\
    \midrule
    $[-1.7\times10^9, -1)$ & $4$ \\
    $[-1, -\delta)$        & $4$ \\
    $[-\delta, \delta)$    & $0$ \\
    $[\delta, 1)$          & $4$ \\
    $[1, 1.7\times10^9)$   & $4$ \\
    \bottomrule
  \end{tabularx}
  \caption{Measured accuracy of vectorized implementation of \texttt{tan}}
  \label{tab:Measured accuracy of vectorized implementation of tan}
\end{table}
