% ============================================================================
%  MCKL/manual/tex/random.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2017, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Random Number Generating}
\label{chap:Random Number Generating}

In this chapter, we first introduce vectorized random number generating in
section~\ref{sec:Vectorized Random Number Generating}. Then a set of \rng
engines are discussed in sections~\ref{sec:Counter-Based Random Number
Generators} to~\ref{sec:Non-Deterministic Random Number Generators}.
Section~\ref{sec:Seeding Random Number Generators} shows how to seed multiple
distinctive \rng instances, either within a single program or across multiple
computing nodes. Section~\ref{sec:Using Multiple Random Number Generators}
shows how multiple \rng instances in a parallelized program can be managed.
Last, a set of distribution generators are discussed in
sections~\ref{sec:Uniform Bits Distribution} to~\ref{sec:Multivariate
Distribution}.

\section{Vectorized Random Number Generating}
\label{sec:Vectorized Random Number Generating}

The generic function |rand| provides vectorized random number generating. There
are two main variants. The first operates on \rng engines and generates random
integers,
\begin{verbatim}
template <typename RNGType>
void rand(RNGType &rng, size_t n, typename RNGType::result_type *r);
\end{verbatim}
For example,
\begin{verbatim}
RNG rng;
constexpr std::size_t n = 1024;
RNG::result_type r[n];
rand(rng, n, r);
\end{verbatim}
The effect of the function call above is equivalent to the following loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = rng();
\end{verbatim}
The results are always the same unless a non-deterministic \rng is used (see
section~\ref{sec:Non-Deterministic Random Number Generators}). For some \rng{}s
implemented in \mckl, the vectorized function may have considerable performance
advantage. See appendix~\ref{chap:Performance of Random Number Generators}.

The second variant of |rand| is for generating distribution random variates,
\begin{verbatim}
template <typename RNGType, typename DistributionType>
void rand(RNGType &rng, DistributionType &distribution, size_t n,
    typename DistributionType::result_type *r);
\end{verbatim}
For example,
\begin{verbatim}
RNG rng;
NormalDistribution<double> normal(mean, sd);
constexpr std::size_t n = 1024;
double r[n];
rand(rng, normal, n, r);
\end{verbatim}
This is similar to the following loop,
\begin{verbatim}
for (size_t i = 0; i != n; ++i)
    r[i] = normal(rng);
\end{verbatim}
Depending on the type of \rng and the distribution (including its parameters),
the vectorized function may have superior performance. See
appendix~\ref{chap:Performance of Distributions}. However, the results are not
always the same as using a loop. The uniform bits distribution (see
section~\ref{sec:Uniform Bits Distribution}) and the standard uniform
distributions (see section~\ref{sec:Standard Uniform Distribution}) will always
produce exactly the same results as using a loop. For some distributions, such
as those using the inverse method, the difference is up to rounding errors. For
others, completely different sequences of random numbers might be generated.

\section{Counter-Based Random Number Generators}
\label{sec:Counter-Based Random Number Generators}

The development by~\cite{Salmon:2011um} made high performance parallel \rng
much more accessible. The \rng{}s introduced in the paper use bijection $f_k$,
such that, for a sequence $\Curly{c_i = i}_{i\ge0}$, the sequence $\Curly{y_i =
f_k(c_i)}_{i\ge0}$ appears random. In addition, for $k_1 \ne k_2$, $f_{k_1}$
and $f_{k_2}$ generate two sequences that appear statistically independent.
Compared to more conventional \rng{}s which use recursions $y_i = f_k(y_{i -
1})$, these counter-based \rng{}s are much easier to use in a parallelized
environment. If~$c$, the counter, is an unsigned integer with~$b$ bits,
and~$k$, the key, is an unsigned integer with~$d$ bits. Then for each $k$, the
\rng has a period~$2^b$. And there can be at most~$2^d$ independent streams.
\mckl defines the following class template as the interface,
\begin{verbatim}
template <typename ResultType, typename Generator>
class CounterEngine;
\end{verbatim}
where |ResultType| shall be an unsigned integer type and it is the output type
of the \rng engine. An instance of this class template is compatible with
standard library \rng engines, and can be used as a drop-in replacement of
classes such as |std::mt19937|. A few generators are implemented in \mckl and
discussed briefly in this section. See~\cite{Salmon:2011um} for details of each
algorithm.

\subsection{AES Round Function Based Random Number Generators}
\label{sub:AES Round Function Based Random Number Generators}

\aes\footnote{\url{https://en.wikipedia.org/wiki/Advanced_Encryption_Standard}}
round function based \rng{}s in~\cite{Salmon:2011um} are implemented in the
following generator.
\begin{verbatim}
template <typename KeySeqType>
class AESGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename KeySeqType>
using AESEngine = CounterEngine<ResultType, AESGenerator<KeySeqType>;
\end{verbatim}
where |KeySeqType| is the class used to generate the sequences of round keys.
When \aesni\footnote{\url{https://en.wikipedia.org/wiki/AES_instruction_set}}
instructions are available, they are used for performance boost. Without going
into details, there are four types of sequences of round keys implemented by
\mckl,
\begin{verbatim}
template <std::size_t Rounds = MCKL_AES128_ROUNDS>
class AES128KeySeq;

template <std::size_t Rounds = MCKL_AES192_ROUNDS>
class AES192KeySeq;

template <std::size_t Rounds = MCKL_AES256_ROUNDS>
class AES256KeySeq;

template <std::size_t Rounds = MCKL_ARS_ROUNDS,
    typename Constants = ARSConstants>
class ARSKeySeq;
\end{verbatim}
The default rounds of the first three are~10, 12 and~14, respectively. And thus
they are equivalent to the \aes-128, \aes-192, and \aes-256 block ciphers,
respectively. The last one is the \ars algorithm in~\cite{Salmon:2011um}. The
default rounds is~5, instead of~7 as in the paper, but the same as its \mkl
implementation. The trait class |Constants| defines the Weyl's sequence
constants. The only restriction on this trait class is that the following
expressions are valid,
\begin{verbatim}
constexpr uint64_t w0 = Constants::weyl::value[0];
constexpr uint64_t w1 = Constants::weyl::value[1];
\end{verbatim}
The member data |value| will not be \odr used. The default constants are taken
from the paper. Correspondingly, there are four \rng engines,
\begin{verbatim}
template <typename ResultType, std::size_t Rounds = MCKL_AES128_ROUNDS>
using AES128Engine = AESEngine<ResultType, AES128KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_AES192_ROUNDS>
using AES192Engine = AESEngine<ResultType, AES192KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_AES256_ROUNDS>
using AES256Engine = AESEngine<ResultType, AES256KeySeq<Rounds>>;

template <typename ResultType, std::size_t Rounds = MCKL_ARS_ROUNDS,
    typename Constants = ARSConstants>
using ARSEngine = AESEngine<ResultType, ARSKeySeq<Rounds, Constants>>;
\end{verbatim}
A few type aliases are defined for convenience.
\begin{verbatim}
using AES128 = AES128Engine<std::uint32_t>;
using AES192 = AES192Engine<std::uint32_t>;
using AES256 = AES256Engine<std::uint32_t>;
using ARS    = ARSEngine<std::uint32_t>;

using AES128_64 = AES128Engine<std::uint64_t>;
using AES192_64 = AES192Engine<std::uint64_t>;
using AES256_64 = AES256Engine<std::uint64_t>;
using ARS_64    = ARSEngine<std::uint64_t>;
\end{verbatim}

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K, size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
class PhiloxGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T, size_t K,
    size_t Rounds = MCKL_PHILOX_ROUNDS,
    typename Constants = PhiloxConstants<T, K>>
using PhiloxEngine =
    CounterEngine<ResultType, PhiloxGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The template parameter |Constants| is a trait class that defines the Weyl's
sequence constants and the multipliers. The only restriction on this trait
class is that the following expressions are valid,
\begin{verbatim}
// i is a compile time constant expression
constexpr T w = Constants::weyl::value[i];       // i = 0, ..., K / 2 - 1
constexpr T m = Constants::multiplier::value[i]; // i = 0, ..., K / 2 - 1
\end{verbatim}
The member data |value| will not be \odr used. The defaults are taken
from~\cite{Salmon:2011um}. Four engines are defined in \mckl,
\begin{verbatim}
template <typename ResultType>
using Philox2x32Engine = PhiloxEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Philox4x32Engine = PhiloxEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Philox2x64Engine = PhiloxEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Philox4x64Engine = PhiloxEngine<ResultType, uint64_t, 4>;
\end{verbatim}
A few type aliases are defined for convenience,
\begin{verbatim}
using Philox2x32 = Philox2x32Engine<uint32_t>;
using Philox4x32 = Philox4x32Engine<uint32_t>;
using Philox2x64 = Philox2x64Engine<uint32_t>;
using Philox4x64 = Philox4x64Engine<uint32_t>;

using Philox2x32_64 = Philox2x32Engine<uint64_t>;
using Philox4x32_64 = Philox4x32Engine<uint64_t>;
using Philox2x64_64 = Philox2x64Engine<uint64_t>;
using Philox4x64_64 = Philox4x64Engine<uint64_t>;
\end{verbatim}

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in~\cite{Salmon:2011um} is implemented in the following
generator,
\begin{verbatim}
template <typename T, size_t K, size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
class ThreefryGenerator;
\end{verbatim}
The corresponding \rng engine is,
\begin{verbatim}
template <typename ResultType, typename T, size_t K,
    size_t Rounds = MCKL_THREEFRY_ROUNDS,
    typename Constants = ThreefryConstants<T, K>>
using ThreefryEngine =
    CounterEngine<ResultType, ThreefryGenerator<T, K, Rounds, Constants>>;
\end{verbatim}
The template parameter |Constants| is a trait class that defines the parity
constants, the rotation constants, and the permutation. The only restriction on
this trait class is that the following expressions are valid,
\begin{verbatim}
// i, j are compile time constant expression
constexpr T k = Constants::parity::value;
constexpr int r = Constants::rotate::value[i][j];  // i = 0, ..., K / 2 - 1
                                                   // j = 1, ..., 8
constexpr size_t p = Constants::permute::value[i]; // i = 0, ..., K - 1
\end{verbatim}
The member data |value| will not be \odr used. The defaults are taken
from the skein\footnote{\url{http://www.skein-hash.info}} hash function
and~\cite{Salmon:2011um}. Six engines are defined in \mckl,
\begin{verbatim}
template <typename ResultType>
using Threefry2x32Engine = ThreefryEngine<ResultType, uint32_t, 2>;

template <typename ResultType>
using Threefry4x32Engine = ThreefryEngine<ResultType, uint32_t, 4>;

template <typename ResultType>
using Threefry2x64Engine = ThreefryEngine<ResultType, uint64_t, 2>;

template <typename ResultType>
using Threefry4x64Engine = ThreefryEngine<ResultType, uint64_t, 4>;

template <typename ResultType>
using Threefry8x64Engine = ThreefryEngine<ResultType, uint64_t, 8>;

template <typename ResultType>
using Threefry16x64Engine = ThreefryEngine<ResultType, uint64_t, 16>;
\end{verbatim}
In addition, three engines that are equivalent to Threefish-256, Threefish-512
and Threefish-1024 block ciphers, respectively, are also defined,
\begin{verbatim}
template <typename ResultType>
using Threefish256Engine = ThreefryEngine<ResultType, uint64_t, 4, 72>;

template <typename ResultType>
using Threefish512Engine = ThreefryEngine<ResultType, uint64_t, 8, 72>;

template <typename ResultType>
using Threefish1024Engine = ThreefryEngine<ResultType, uint64_t, 16, 80>;
\end{verbatim}
A few type aliases are defined for convenience,
\begin{verbatim}
using Threefry2x32  = Threefry2x32Engine<uint32_t>;
using Threefry4x32  = Threefry4x32Engine<uint32_t>;
using Threefry2x64  = Threefry2x64Engine<uint32_t>;
using Threefry4x64  = Threefry4x64Engine<uint32_t>;
using Threefry8x64  = Threefry8x64Engine<uint32_t>;
using Threefry16x64 = Threefry16x64Engine<uint32_t>;

using Threefry2x32_64  = Threefry2x32Engine<uint64_t>;
using Threefry4x32_64  = Threefry4x32Engine<uint64_t>;
using Threefry2x64_64  = Threefry2x64Engine<uint64_t>;
using Threefry4x64_64  = Threefry4x64Engine<uint64_t>;
using Threefry8x64_64  = Threefry8x64Engine<uint64_t>;
using Threefry16x64_64 = Threefry16x64Engine<uint64_t>;

using Threefish256  = Threefish256Engine<uint32_t>;
using Threefish512  = Threefish512Engine<uint32_t>;
using Threefish1024 = Threefish1024Engine<uint32_t>;

using Threefish256_64  = Threefish256Engine<uint64_t>;
using Threefish512_64  = Threefish512Engine<uint64_t>;
using Threefish1024_64 = Threefish1024Engine<uint64_t>;
\end{verbatim}

\section{MKL Random Number Generators}
\label{sec:MKL Random Number Generators}

\mkl provides some high performance \rng{}s. \mckl implements a wrapper class
\begin{verbatim}
template <MKL_INT BRNG, int Bits>
class MKLEngine;
\end{verbatim}
that makes them accessible as \cpp engines. The output is either~32- or~64-bit
unsigned integers. This is determined by the template parameter |Bits|, which
can only take one of these two values. The template parameter |BRNG| can be any
\mkl \brng macro that supports |viRngUniformBits32| (|Bits| is~32) or
|viRngUniformBits64| (|Bits| is~64). Type aliases are listed below,
\begin{verbatim}
using MKL_ARS5             = MKLEngine<VSL_BRNG_ARS5, 32>;
using MKL_ARS5_64          = MKLEngine<VSL_BRNG_ARS5, 64>;
using MKL_PHILOX4X32X10    = MKLEngine<VSL_BRNG_PHILOX4X32X10, 32>;
using MKL_PHILOX4X32X10_64 = MKLEngine<VSL_BRNG_PHILOX4X32X10, 64>;
using MKL_MCG59            = MKLEngine<VSL_BRNG_MCG59, 32>;
using MKL_MCG59_64         = MKLEngine<VSL_BRNG_MCG59, 64>;
using MKL_MT19937          = MKLEngine<VSL_BRNG_MT19937, 32>;
using MKL_MT19937_64       = MKLEngine<VSL_BRNG_MT19937, 64>;
using MKL_MT2203           = MKLEngine<VSL_BRNG_MT2203, 32>;
using MKL_MT2203_64        = MKLEngine<VSL_BRNG_MT2203, 64>;
using MKL_SFMT19937        = MKLEngine<VSL_BRNG_SFMT19937, 32>;
using MKL_SFMT19937_64     = MKLEngine<VSL_BRNG_SFMT19937, 64>;
using MKL_NONDETERM        = MKLEngine<VSL_BRNG_NONDETERM, 32>;
using MKL_NONDETERM_64     = MKLEngine<VSL_BRNG_NONDETERM, 64>;
\end{verbatim}
Note that, \mkl \rng{}s perform the best when they are used to generate vectors
of random numbers. These wrappers use a buffer to store such vectors. And thus
they have much larger state space than usual \rng{}s. When there are \mkl
routines for generating distribution random variates for one of the
distributions discussed later in sections~\ref{sec:Continuous Distribution}
and~\ref{sec:Discrete Distribution}, \mckl automatically uses these routines
for vectorized random number generating if the \rng is one of that listed
above. For example,
\begin{verbatim}
MKL_MT2203 rng;
NormalDistribution<double> normal;
normal(rng, n, r);       // MKL rountines used
rand(rng, normal, n, r); // MKL rountines used
\end{verbatim}
Note that, this is applicable when the distribution is a class in \mckl. It
does not work with classes such as |std::normal_distribution|. This is also
applicable when the distribution is not directly supported by \mkl, but can be
easily generated using other distributions, e.g., the Student's
$t$-distribution. In addition, it is also applicable if a distribution is a
special case of one of the distributions supported by \mkl, e.g., the
$\chi^2$-distribution.

\section{Non-Deterministic Random Number Generators}
\label{sec:Non-Deterministic Random Number Generators}

If \rdrand\footnote{\url{https://en.wikipedia.org/wiki/RdRand}} instructions
are supported, \mckl also implements three non-deterministic \rng{}s,
|RDRAND16|, |RDRAND32| and |RDRAND64|. They output~16-, 32-, and~64-bit random
integers, respectively. \rdrand instructions may not return a random integer at
all. The \rng engine keeps trying until it succeeds. One can limit the maximum
number of trials by defining the configuration macro |MCKL_RDRAND_NTRIAL_MAX|.
A value of zero, the default, means the number of trials is unlimited. If it is
a positive number, and if after the specified number of trials no random
integer is returned by \rdrand instructions, zero is returned.

\section{Seeding Random Number Generators}
\label{sec:Seeding Random Number Generators}

The following singleton class template,
\begin{verbatim}
template <typename ResultType,
    typename ID = std::integral_constant<std::size_t, sizeof(ResultType)>,
    bool Randomize = true, bool Atomic = true>
class SeedGenerator;
\end{verbatim}
can be used to generate distinctive seeds. The method |instance| returns a
reference to the singleton. For example,
\begin{verbatim}
auto &seed = SeedGenerator<unsigned>::instance();      // Generate integers
auto &keys = SeedGenerator<ARS::key_type>::instance(); // Generate keys for ARS
\end{verbatim}
Different combinations of the template parameters will create different
instances of the singleton. To generate new seeds,
\begin{verbatim}
RNG rng1(seed.get()); // Construct rng1 with a random seed
RNG rng2(seed.get()); // Construct rng2 with a different random seed
ARS ars1(keys.get()); // Construct ars1 with a random key
ARS ars2(keys.get()); // Construct ars2 with a different random key
\end{verbatim}
The procedure for generating the seeds is described here. Let $N$ be the total
number of bits of |ResultType|, that is,
\begin{verbatim}
constexpr int N = sizeof(ResultType) * CHAR_BIT;
\end{verbatim}
If $N$ is not a multiple of~32, then a compile time error will be raised.
Otherwise, let $S = \min\Curly{N,64}$ and $M = N / S$. The generator keeps an
$S$-bit unsigned integer as its internal counter, say $c$. Use the |set| method
to set the value of this internal integer. For example,
\begin{verbatim}
seed.set(101);
\end{verbatim}
Each time a new seed is requested, this counter is incremented. If the template
parameter |Atomic| is true, then this increment is atomic and thread-safe. Let
the old value be $s$, that is,
\begin{equation*}
  s \leftarrow c,\qquad c \leftarrow c + 1.
\end{equation*}
The generator first calculates an $N$-bit unsigned integer $t$ as the
following.
\begin{equation*}
  t = \begin{cases}
    (s \bmod m) p + r &\text{if } M = 1 \\
    s + 2^{N - S}r    &\text{otherwise}
  \end{cases},
\end{equation*}
where $m = (2^S - 1 - r) / p + 1$, $p = 1$ and $r = 0$ by default. To change
their values, use the |partition| method. For example,
\begin{verbatim}
seed.partition(10, 3); // p = 10, r = 3
\end{verbatim}
Last, if |Randomize| is false, then $t$ is returned as the requested seed, with
possible reordering of bytes on big-endian platforms such that the results are
exactly the same as on little-endian platforms. Otherwise, i.e., |Randomize| is
true, then $t$ is transformed through a randomize function. If $N = 32$, then
it is transformed using a~32-bit Speck block
cipher\footnote{\url{https://en.wikipedia.org/wiki/Speck_(cipher)}} with a zero
key. If $N = 2^W$, $W = 5,\dots,10$, then it is transformed with the bijection
of |Threefry2x32|, |Threefry2x64|, |Threefry4x64|, |Threefry8x64|, and
|Threefry16x64| \rng{}s with zero keys, respectively. Otherwise, it is
transformed with the Skein-512 hash function.

It is clear that, if $N = 2^W$, $W = 5,\dots,10$, or |Randomize| is false, then
the seeds generated are always distinctive if the values of the internal
counter $c$ are distinctive. Therefore, the seed generator has a period of
$\Floor{2^S / p}$ if $M = 1$ and $2^S$ if $M > 1$. Moreover, the values of $t$
belongs to the equivalent class $t \equiv r \pmod{p}$ if $M = 1$ and $\Floor{t
/ 2^{N - S}} \equiv r$ if $M > 1$. Therefore, using the |partition| method, one
can generate distinctive seeds across multiple computing nodes or multiple
programs.

One can save and restore the seed generator using standard library streams. For
example,
\begin{verbatim}
std::ifstream is("seed.txt");
if (is)
    is >> Seed<RNG>::instance();    // Read seed from a file
if (!is)
    Seed<RNG>::instance().set(101); // Set it manually
is.close();
// Using Seed
std::ofstream os("seed.txt");
os << Seed<RNG>::instance();        // Write the seed to a file
os.close();
\end{verbatim}
This is useful when one need to run a simulation program multiple times, but
need a different set of seeds for each run.

Last, the following class is defined for convenience,
\begin{verbatim}
template <typename RNGType>
class Seed;
\end{verbatim}
which is a derived class of the following generator,
\begin{verbatim}
SeedGenerator<typename SeedType<RNGType>>;
\end{verbatim}
where |SeedType| is an alias to |SeedTrait<RNGType>::type|,
\begin{verbatim}
template <typename RNGType>
class SeedTrait
{
    public:
    using type = unsigned;
};

template <typename ResultType, typename Generator>
class SeedTrait<CounterEngine<ResultType, Generator>>
{
    public:
    using type = typename CounterEngine<ResultType, Generator>::key_type;
};
\end{verbatim}
Therefore, for most \rng{}s, the unsigned integers are generated as seeds and
they share the same internal counter $c$. For counter-based \rng{}s implemented
in \mckl, keys will be generated as seeds and \rng{}s with the same key width
will share the same internal counter $c$.

\section{Using Multiple Random Number Generators}
\label{sec:Using Multiple Random Number Generators}

The class template |RNGSet| can be used to manage multiple \rng instances
within a parallel program. Three of them are implemented in \mckl. They all
have the same interface,
\begin{verbatim}
RNGSet<RNG> rng_set(N); // A set of N RNGs
rng_set.resize(n);      // Change the size of the set
rng_set[i];             // Get a reference to the i-th RNG
rng_set.reset();        // Re-seed each RNG in the set
\end{verbatim}
The |reset| method use |Seed<RNG>| discussed earlier to generate new seeds.

The first implementation is |RNGSetScalar|. As its name suggests, it is only a
wrapper of a single \rng. All calls to |rng_set[i]| returns a reference to the
same \rng. It is only useful when an |RNGSet| interface is required while the
thread-safety and other issues are not important. The second implementation is
|RNGSetVector|. It is an array of \rng{}s with length~$N$. It has memory cost
$O(N)$. Many of the counter-based \rng{}s (see section~\ref{sec:Counter-Based
Random Number Generators}) have small state sizes and thus for moderate~$N$,
this cost is not significant. The method calls |rng_set[i]| and |rng_set[j]|
return independent \rng{}s if $i \ne j$. If \tbb is available, there is a third
implementation, |RNGSetTBB|, which uses thread-local storage (\tls). It has
much smaller memory footprint than |RNGSetVector| while maintains better
thread-safety. The type alias |RNGSet| is defined to be |RNGSetTBB| if \tbb is
available. Otherwise it is defined to be |RNGSetVector|.

\section{Uniform Bits Distribution}
\label{sec:Uniform Bits Distribution}

The class template,
\begin{verbatim}
template <typename UIntType>
class UniformBitsDistribution;
\end{verbatim}
is similar to the standard library's |std::independent_bits_engine|, except
that it always generates full size random integers and |UIntType| must have
a size of at least of 16 bits. That is, let~$W$ be the number of bits of
|UIntType|, then the output is uniform on the set $\Curly{0,\dots,2^W - 1}$.
For example,
\begin{verbatim}
UniformBitsDistribution<uint32_t> ubits;
ubits(rng); // Return 32-bit random integers
\end{verbatim}
Let $\rmin$ and $\rmax$ be the minimum and maximum of the random integers
generated by |rng|. Let $R = \rmax - \rmin + 1$. Let $r_i$ be consecutive
output of |rng()|. If there exists an integer $V > 0$ such that $R = 2^V$, then
the result is,
\begin{equation*}
  U = \sum_{k = 0}^{K - 1} (r_k - \rmin) 2^{kV} \bmod 2^W
\end{equation*}
where $K = \Ceil{W / V}$. Unlike |std::independent_bits_engine|, the
calculation can be vectorized, which leads to better performance. Note that,
all constants in the algorithm are computed at compile-time and the summation
is fully unrolled. There is no runtime overhead. In the case $\rmin = 0$ and $V
= W$, most optimizing compilers shall be able to generate instructions such
that the distribution does exactly nothing and returns the results of |rng()|
directly. If there does not exist an integer $V > 0$ such that $R = 2^V$, then
|std::indepdent_bits_engine| is used.

\section{Standard Uniform Distribution}
\label{sec:Standard Uniform Distribution}

\mckl provides five standard uniform distributions. They are all class
templates with a single template type parameter |RealType|. The random integers
produced by \rng{}s are transferred to~32- or~64-bit random integers through
the class |UniformBitsDistribution| before they are mapped to floating point
numbers within the interval $[0, 1]$. The integer type depends on |RealType|
and the range of the \rng{}, $R$. If $\log_2 R \ge 64$ or |RealType| is
|long double|, then the integer type is |uint64_t|. If
|MCKL_U01_USE_64BITS_DOUBLE| is true and |RealType| is |double|, then the
integer type is also |uint64_t|. Otherwise, the integer type is |uint32_t|.

In the following, let~$W$ be the number of bits of the integer type, and~$M$ be
the number of significant bits (including the implicit one) of |RealType|. We
also denote the input random integers as~$U$ and the output random real numbers
as~$X$. The type |U01Distribution| is aliased to |U01CanonicalDistribution| if
the |MCKL_U01_USE_FIXED_POINT| is set to false (the default). Otherwise it is
aliased to |U01CODistribution|.

\subsection{Canonical Form}
\label{sub:Canonical Form}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CanonicalDistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$. It is implemented through the
mapping,
\begin{equation*}
  P = \Floor{(W + M - 1) / W},\qquad
  K = \max\Curly{1, P},\qquad
  X = \sum_{k=0}^{K - 1} U_k 2^{-(K - k)W}
\end{equation*}
This is equivalent to the standard library |std::generate_canonical|. The
minimum and maximum are~$0$ and~$1 - 2^{-KW}$, respectively.

\subsection{Closed-Closed Interval}
\label{sub:Closed-Closed Interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CCDistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1]$ through the mapping,
\begin{align*}
  P &= \min\Curly{W - 1, M}, &
  V &= \begin{cases}
    U &\text{if } P + 1 < W \\
    \Floor{(U \bmod 2^{W - 1}) / 2^{W - P -2}} &\text{otherwise}
  \end{cases}, \\
  Z &= (V \bmod 2) + V, &
  X &= 2^{-(P + 1)} Z.
\end{align*}
The minimum and maximum are~$0$ and~$1$, respectively.

\subsection{Closed-Open Interval}
\label{sub:Closed-Open Interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $[0, 1)$ through the mapping,
\begin{equation*}
  P = \min\Curly{W, M},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V.
\end{equation*}
The minimum and maximum are~$0$ and~$1 - 2^{-P}$, respectively.

\subsection{Open-Closed Interval}
\label{sub:Open-Closed Interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01OCDistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1]$ through the mapping,
\begin{equation*}
  P = \min\Curly{W, M},\qquad
  V = \Floor{U / 2^{W - P}},\qquad
  X = 2^{-P} V + 2^{-P}.
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1$, respectively.

\subsection{Open-Open Interval}
\label{sub:Open-Open Interval}

The class template,
\begin{verbatim}
template <typename RealType = double>
class U01CODistribution;
\end{verbatim}
implements the uniform distribution on $(0, 1)$ through the mapping,
\begin{equation*}
  P = \min\Curly{W + 1, M},\qquad
  V = \Floor{U / 2^{W + 1 - P}},\qquad
  X = 2^{-(P - 1)} V + 2^{-P}.
\end{equation*}
The minimum and maximum are~$2^{-P}$ and~$1 - 2^{-P}$, respectively.

\section{Continuous Distribution}
\label{sec:Continuous Distribution}

\subsection{Arcsine Distribution}
\label{sub:Arcsine Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ArcsineDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) = \frac{1}{\pi\sqrt{(x - \alpha)(\beta - x)}},\qquad
  x \in [a, b],\quad a \in (0,\infty),\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Beta Distribution}
\label{sub:Beta Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class BetaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)}
  x^{\alpha - 1}(1 - x)^{\beta - 1},\qquad
  x \in (0, 1),\quad \alpha \in (0,\infty),\quad \beta \in (0,\infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1/2$ and
$\beta = 1/2$, or $\alpha = 1$ or $\beta = 1$, then the inverse method is used.
If $\alpha > 1$ and $\beta > 1$, the method in~\cite{Cheng:1978jl} is used.
Otherwise, let $K = 0.852$, $C = -0.956$, and $D = \beta + K\alpha^2 + C$. If
$\alpha < 1$, $\beta < 1$ and $D \le 0$, then Jöhnk's
method~\cite[sec.~3.5]{Devroye:1986gi} is used. In all other cases, one of the
switching algorithms in~\cite{Atkinson:1979es} is used.

\subsection{Cauchy Distribution}
\label{sub:Cauchy Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class CauchyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{\pi b\Round[Big]{1 + \Round[Big]{\frac{x - a}{b}}^2}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{\texorpdfstring{$\chi^2$}{Chi-squared}-Distribution}
\label{Chi-Squared-Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ChiSquaredDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) = \frac{x^{n/2 - 1}\EE^{-x/2}}{2^{n/2}\Gamma(n/2)},\qquad
  x \in (0,\infty),\quad n \in (0,\infty).
\end{equation*}
The implementation uses the fact that if~$X$ is a Gamma random variable with
shape $n / 2$ and scale~$2$, then~$X$ is also $\chi^2$-distributed with degree
of freedom $n$.

\subsection{Exponential Distribution}
\label{sub:Exponential Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExponentialDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\lambda) = \lambda\EE^{-\lambda x},\qquad
  x \in [0,\infty),\quad \lambda \in (0,\infty),
\end{equation*}
using the inverse method.

\subsection{Extreme Value Distribution}
\label{sub:Extreme Value Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ExtremeValueDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \frac{1}{b}\exp\Curly[Big]{
    \frac{a - x}{b} - \exp\Curly[Big]{\frac{a - x}{b}}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Fisher's \texorpdfstring{$F$}{F}-Distribution}
\label{sub:Fisher's F-distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class FisherFDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  & f(x;m,n) =
  \frac{\Gamma\Round[Big]{\frac{m + n}{2}}}{
    \Gamma\Round[Big]{\frac{m}{2}}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{\frac{m}{n}}^{m/2} x^{m / 2 - 1}
  \Round[Big]{1 + \frac{m}{n}x}^{-(m + n) / 2} \\
  & x \in [0, \infty),\quad m \in (0, \infty),\quad n \in (0, \infty).
\end{align*}
The implementation uses the fact that if~$U$ and~$V$ are $\chi^2$-distributed
random variables with degrees of freedom~$m$ and~$n$, respectively, and they
are independent, then $X = (U / V)(m / n)$ is a Fisher's $F$-distributed random
variable with the respective degrees of freedom.

\subsection{Gamma Distribution}
\label{sub:Gamma Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class GammaDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\alpha,\beta) =
  \frac{\EE^{-x/\beta}}{\Gamma(\alpha)}\beta^{-\alpha}x^{\alpha-1},\qquad
  x \in (0, \infty),\quad \alpha \in (0, \infty),\quad \beta \in (0, \infty).
\end{equation*}
The specific algorithm used depends on the parameters. If $\alpha = 1$, it
becomes the exponential distribution. If $0 < \alpha < 0.6$, it is generated
through transformation of exponential power
distribution~\cite[sec~2.6]{Devroye:1986gi}. If $0.6\le\alpha<1$, then
rejection method from the Weibull distribution is
used~\cite[sec.~3.4]{Devroye:1986gi}. If $\alpha > 1$, then the method
in~\cite{Marsaglia:2000vq} is used.

\subsection{Laplace Distribution}
\label{sub:Laplace Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{2b}\exp\Curly[Big]{-\frac{\Abs{x - a}}{b}},\qquad
  x \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Levy Distribution}
\label{sub:Levy Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LevyDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) =
  \sqrt{\frac{b}{2\pi}}
  \frac{\exp\Curly[Big]{-\frac{b}{2(x - a)}}}{(x - a)^{3/2}},\qquad
  x \in [a, \infty),\quad a \in \Real,\quad b \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then $X = a + b / Z^2$ is Levy distributed with location~$a$ and
scale~$b$.

\subsection{Logistic Distribution}
\label{sub:Logistic Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LaplaceDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{4b}\mathrm{sech}^2\Round[Big]{\frac{x - a}{2b}},\qquad
  x \in \Real,\quad a \in \Real,\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Log-Normal Distribution}
\label{sub:Log-Normal Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class LognormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;m,s) =
  \frac{1}{x\sigma\sqrt{2\pi}}
  \exp\Curly[Big]{-\frac{(\ln x - m)^2}{2\sigma^2}},\qquad
  x \in (0, \infty),\quad m \in \Real,\quad s \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, then $X = \exp\Curly{m + sZ}$ is Log-normal distributed with
location~$m$ and scale~$s$.

\subsection{Normal Distribution}
\label{sub:Normal Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class NormalDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\mu,\sigma) =
  \frac{1}{\sqrt{2\pi\sigma^2}}
  \exp\Curly[Big]{-\frac{(x-\mu)^2}{2\sigma^2}},\qquad
  x \in \Real,\quad \mu \in \Real,\quad \sigma \in (0, \infty),
\end{equation*}
using the Box-Muller method~\cite{Box:1958hv}.

\subsection{Pareto Distribution}
\label{sub:Pareto Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class ParetoDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a b^a}{x^{a + 1}},\qquad
  x \in [b, \infty),\quad a \in [0, \infty),\quad b \in [0, \infty),
\end{equation*}
using the inverse method.

\subsection{Rayleigh Distribution}
\label{sub:Rayleigh Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class RayleighDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;\sigma) =
  \frac{x}{\sigma^2}\exp\Curly[Big]{-\frac{x^2}{2\sigma^2}},\qquad
  x \in [0, \infty),\quad \sigma \in (0, \infty),
\end{equation*}
using the inverse method.

\subsection{Stable Distribution}
\label{sub:Stable Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StableDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x;\alpha,\beta,a,b) =
  \frac{1}{2\pi}\int_{\infty}^{\infty}
  \varphi(t;\alpha,\beta,a,b)\EE^{-ixt}\intd t\\
  &\varphi(t;\alpha,\beta,a,b) =
  \exp\Curly{
    ita - \Abs{bt}^{\alpha}(1 - i\beta\mathrm{sgn}(t)\Phi(t;\alpha))} \\
  &\Phi(t;\alpha) = \begin{cases}
    \tan\Round[big]{\frac{\pi}{2}\alpha} & \alpha \ne 1 \\
    -\frac{2}{\pi}\log\Abs{t}            & \alpha = 1
  \end{cases} \\
  & x \in \Real,\quad
  \alpha \in (0, 2],\quad \beta \in [-1, 1],\quad
  a \in \Real,\quad b \in (0, \infty).
\end{align*}
The implementation uses the method in~\cite{Chambers:1976dv}.

\subsection{Student's \texorpdfstring{$t$}{t}-Distribution}
\label{sub:Student's t-Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class StudentTDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;n) =
  \frac{\Gamma\Round[Big]{\frac{n + 1}{2}}}
  {\sqrt{n\pi}\Gamma\Round[Big]{\frac{n}{2}}}
  \Round[Big]{1 + \frac{x^2}{n}}^{-(n + 1)/2},\qquad
  x \in \Real,\quad n \in (0, \infty).
\end{equation*}
The implementation uses the fact that if~$Z$ is a standard Normal random
variable, $V$ is a $\chi^2$-distributed random variable with degree of freedom
$n$, and they are independent, then $X = Z/\sqrt{V / n}$ is Student's
$t$-distributed with the respective degree of freedom.

\subsection{Uniform Real Distribution}
\label{sub:Uniform Real Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class UniformRealDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{1}{b - a},\qquad
  x \in [a, b),\quad a \in \Real,\quad b \in (a, \infty),
\end{equation*}
using the inverse method.

\subsection{Weibull Distribution}
\label{sub:Weibull Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double>
class WeibullDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x;a,b) = \frac{a}{b}\Round[Big]{\frac{x}{b}}^{a - 1}
  \exp\Curly[Big]{-\Round[Big]{\frac{x}{b}}^a},\qquad
  x \in [0, \infty),\quad a \in (0, \infty),\quad b \in (0, \infty),
\end{equation*}
using the inverse method.

\section{Discrete Distribution}
\label{sec:Discrete Distribution}

\subsection{Bernoulli Distribution}
\label{sub:Bernoulli Distribution}

The class template,
\begin{verbatim}
template <typename IntType = bool>
class BernoulliDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = kp + (1 - k)(1 - p),\qquad
  k \in \Curly{0, 1},\quad p \in [0, 1].
\end{equation*}
Unlike other discrete distributions, the Bernoulli distribution supports any
integer type, while others require an integer type with size larger than 16
bits. The implementation uses the simple fact that if~$U$ is a standard uniform
random variable, than $\bbI_{[0,p)}(U)$ is Bernoulli distributed with success
probability~$p$. This is not a drop-in replacement for
|std::bernoulli_distribution|, which is not a class template.

\subsection{Geometric Distribution}
\label{sub:Geometric Distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class GeometricDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;p) = p(1-p)^k,\qquad
  k \in \Natural,\quad p \in (0, 1].
\end{equation*}
The implementation uses the fact that if~$U$ is a standard uniform random
variable, then $X = \Floor{\ln U / \ln(1-p)}$ is a Geometric random variable
with success probability~$p$.

\subsection{Uniform Integer Distribution}
\label{sub:Uniform Integer Distribution}

The class template,
\begin{verbatim}
template <typename IntType = int>
class UniformIntDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  \Prob(X = k;a,b) = \frac{1}{b - a + 1},\qquad
  k \in \Curly{a,\dots,b},\quad
  a \in \Integer,\quad b \in \Set{x \in \Integer \mid x \ge a}.
\end{equation*}
The specific algorithm used depends on the parameters. If $a = b$, then it
simply returns~$a$. If $b - a + 1 = 2^W$, where~$W$ is the number of bits of
|IntType|, then |UniformBitsDistribution| is used (see section~\ref{sec:Uniform
Bits Distribution}). If $\max\Curly{\Abs{a}, b} < 2^{32}$, then it uses the
fact that if~$U$ is a standard uniform random variable, then $X = \Floor{a + (b
  - a + 1) U}$ is uniform on the set $\Curly{a,\dots,b}$. Otherwise the
standard library is used.

\section{Multivariate Distribution}
\label{sec:Multivariate Distribution}

\subsection{Dirichlet Distribution}
\label{sub:Dirichlet Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class DirichletDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{equation*}
  f(x_{1:d};\alpha_{1:d}) =
  \frac{\Gamma\Round[Big]{\sum_{i=1}^d\alpha_i}}{\prod_{i=1}^d\Gamma(\alpha_i)}
  \prod_{i=1}^d x_i^{\alpha_i - 1},\qquad
  \sum_{i=1}^d x_i = 1,\quad
  x_{1:d}\in(0,1)^d,\quad
  \alpha_{1:d}\in(0,\infty)^d.
\end{equation*}
The template parameter |Dim| is the dimension of the distribution. If it is
positive, then the dimension is fixed. The distribution generator can be
constructed by,
\begin{verbatim}
DirichletDistribution<double, Dim> dirichlet(alpha);
\end{verbatim}
and if it is zero (recall that |Dynamic| is just an enumerator with value
zero), then the dimension has to be specified at runtime. The distribution
generator can be constructed by,
\begin{verbatim}
DirichletDistribution<double> dirichlet(dim, alpha);
\end{verbatim}
The parameter |alpha| can be either a pointer to a $d$-vector or a scalar. If
it is a scalar, say $\alpha$, then $\alpha_i = \alpha$ for $i = 1,\dots,d$. To
generate one random variate,
\begin{verbatim}
dirichlet(rng, r);
rand(rng, dirichlet, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
dirichlet(rng, n, r);
rand(rng, dirichlet, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.

\subsection{Multivariate Normal Distribution}
\label{sub:Multivariate Normal Distribution}

The class template,
\begin{verbatim}
template <typename RealType = double, size_t Dim = Dynamic>
class NormalMVDistribution;
\end{verbatim}
implements the distribution with \pdf,
\begin{align*}
  &f(x_{1:d};\mu_{1:d},\Sigma) = \frac{1}{\sqrt{(2\pi)^d\Abs{\Sigma}}}
  \exp\Curly[Big]{-\frac{1}{2}(x_{1:d} -
  \mu_{1:d})^{\transpose}\Sigma^{-1}(x_{1:d} - \mu_{1:d})},\\
  &x_{1:d}\in\Real^d,\quad
  \mu_{1:d}\in\Real^d,\quad
  \Sigma\in
  \Curly{\text{positive semi-definite }d\text{ by }d\text{ matrix}}.
\end{align*}
At the time of writing, only |float| and |double| are supported types for the
template parameter |RealType|. The second template parameter |Dim| specify the
dimension of the distribution, $d$. If |Dim| is positive, then the dimension is
fixed. The distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double, Dim> normal_mv(mean, chol);
\end{verbatim}
Otherwise, if |Dim| is zero, the dimension has to be specified at runtime. The
distribution generator can be constructed by,
\begin{verbatim}
NormalMVDistribution<double> normal_mv(d, mean, chol);
\end{verbatim}
In either case, the parameter |mean| is a pointer to the mean vector of length
$d$, and |chol| is a pointer to the lower triangular of the Cholesky
decomposition of the covariance matrix packed row by row. For those unfamiliar
with matrix storage schemes, this means that, |chol| is a vector of length
$d(d + 1) / 2$. Let~$L$ be the lower triangular of the Cholesky decomposition,
that is $LL^{\transpose} = \Sigma$, then the vector is
$(L_{1,1},L_{2,1},L_{2,2},\dots,L_{d,d})^{\transpose}$. Further, both |mean|
and |chol| can also be scalars instead of pointers to vectors. If |mean| is a
scalar, say $\mu$, then the mean vector is assumed to be a $d$-vector with all
elements equal to $\mu$. If |chol| is a scalar, say $\sigma$, then it is
assumed that $L = \sigma I_d$ and thus the covariance matrix is $\Sigma =
\sigma^2 I_d$, where $I_d$ is the identity matrix. To generate a single
multivariate Normal random number,
\begin{verbatim}
normal_mv(rng, r);
rand(rng, normal_mv, r);
\end{verbatim}
where the output parameter |r| is a pointer to a $d$-vector. Vectorized
generating is also possible,
\begin{verbatim}
normal_mv(rng, n, r);
rand(rng, normal_mv, n, r);
\end{verbatim}
where the output parameter |r| is a pointer to an~$n$ by~$d$ matrix of row
major order.
