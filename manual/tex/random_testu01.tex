% ============================================================================
%  MCKL/manual/tex/random_testu01.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{TestU01 results}
\label{chap:TestU01 results}

All \rng{}s implemented in \mckl and those in the standard library are tested
with the \testu library~\cite{Lecuyer:2007hv} test batteries (``SmallCrush'',
``Crush'' and ``BigCrush''). Each battery performs tests on a sequence of real
numbers to detect if it is distinguishable from the uniform distribution on
$[0, 1)$. For each \rng, six types of sequences are tested, each of them
generated by the following classes,
\begin{verbatim}
std::uniform_real_distribution<double>;
U01Distribution<double>;
U01CCDistribution<double>;
U01CODistribution<double>;
U01OCDistribution<double>;
U01OODistribution<double>;
\end{verbatim}
They are labeled as ``\std'', ``\textsc{u01}'', ``\textsc{u01cc}'',
``\textsc{u01co}'', ``\textsc{u01oc}'' and ``\textsc{u01oo}'', respectively, in
the tables below. See section~\ref{sec:Standard uniform distribution} for
details of the last six distributions. The configuration macro
|MCKL_U01_USE_FIXED_POINT| is set to false. Therefore \std and \textsc{u01}
both uses the same algorithm, though not identical in their implementations.
The former use |std::generate_canonical|. The configuration macro
|MCKL_U01_USE_64BITS_DOUBLE| is also set to false. Thus the four fixed point
distributions only uses 32-bit random random integers unless the \rng itself
generates 64-bit integers. All \rng{}s in \mckl come with both 32- and 64-bit
versions. The test results of the 32-bit version when this macro is set to true
shall be the same as their 64-bit counter-parts.

The sequence of random numbers fed into the \testu batteries are constructed as
the following. For each \rng, eight instances of it is created with random
seeds. Let the sequence of random numbers produced by them be $U_{i,j}$, $i =
0,\dots,7$ and $j\ge0$. The $k$\ith random number fed into the batteries is
$U_{p(k), q(k)}$, where,
\begin{equation*}
  p(k) = \Floor{k / 1024} \bmod 8, \qquad q(k) = k \bmod 1024.
\end{equation*}
In words, the first $1024$ random numbers come from the first \rng. Then
another $1024$ random numbers come from the second \rng, and so on. Once all
eight \rng{}s are used, we start with the first one again. This is to mimic the
usage of \rng{}s in a parallel environment with eight threads, each thread uses
one \rng.

For each test within the batteries, one or more $p$-values are produced. A
$p$-value outside the range $(10^{-6}, 1 - 10^{-6})$ is considered a failure.
Otherwise, a $p$-value outside the range $(10^{-3}, 1 - 10^{-3})$ is considered
suspicious. For each test, if any one of the $p$-values produced is a failure,
we consider the \rng to fail the test. On the other hand, if the $p$-values
produced are suspicious, the particular test is repeated two more times, with
new random seeds for each \rng instances. If the total number of suspicious
$p$-values for the test is more than one, either from one run of a test that
produces multiple $p$-values, or repeated runs of a test that produces a single
$p$-value, the \rng is considered to fail the test as well.

It is best to perform each test multiple times to increase the power of the
test. A $p$-value within the range $(10^{-3}, 1 - 10^{-3})$ actually tells very
little about the quality of the \rng. However, the most strident battery,
BigCrush, takes many hours to finish for any \rng. And there are 60 of them to
be tested, each with six distributions. We choose to only perform repeated
tests for those with suspicious $p$-values. The tables below lists the number
of failed tests for each \rng. Those that do not fail any test are omitted.

Note that, only the \std, \textsc{u01} and \textsc{u01co} methods produce
random numbers within the interval $[0, 1)$. Other fixed point distributions
might fail a few tests due to the fact they are supposed to produce random
numbers from other distributions. For example, for the \textsc{u01oc} and
\textsc{u01cc} methods, if ever their upper bond, $1$, is produced in the
sequence, some tests are certain to fail. However, since the chance of it being
produced shall be roughly $2^{-32}$ for 32-bit \rng{}s and $2^{-53}$ for 64-bit
\rng{}s, if an \rng fails many tests in a battery, it is unlikely to be due to
this reason. If an \rng fails considerably more tests with the fixed point
distribution than with the \std and \textsc{u01} methods, then it is more
likely to be due to the weakness of its randomness at the bit level. Recall
that, the \mckl distributions, especially the fixed point ones, relies on the
bit level randomness of the integers produced by the \rng. In particular,
|std::ranlux24_base| and |std::ranlux48_base| are ill-suited to be used with
any of the distributions in \mckl.

Last but not least, the test method used here may uncover defects in \rng{}s
when multiple instances are used concurrently, such as inter-stream
correlations. On the other hand, it may also hide some defects of long streams
from a particular \rng. For example, The linear and general feedback shift
register generators (such as |std::mt19937|) are known to fail linear
dependencies tests. However, as the stream fed into the batteries is actually
mixture of multiple \rng{}s initialized with random seeds, these tests may or
may not fail, depending on the seeds.

\newpage

\begin{table}
  \input{tab/random_testu01_smallcrush}%
  \caption{\testu SmallCrush results (sequential)}
  \label{tab:TestU01 SmallCrush results (sequential)}
\end{table}

\begin{table}
  \input{tab/random_testu01_smallcrush_p}%
  \caption{\testu SmallCrush results (parallel)}
  \label{tab:TestU01 SmallCrush results (parallel)}
\end{table}

\clearpage

\begin{table}
  \input{tab/random_testu01_crush}%
  \caption{\testu Crush results (sequential)}
  \label{tab:TestU01 Crush results (sequential)}
\end{table}

\begin{table}
  \input{tab/random_testu01_crush_p}%
  \caption{\testu Crush results (parallel)}
  \label{tab:TestU01 Crush results (parallel)}
\end{table}

\clearpage

% \begin{table}
%   \input{tab/random_testu01_bigcrush}%
%   \caption{\testu BigCrush results (sequential)}
%   \label{tab:TestU01 BigCrush results (sequential)}
% \end{table}

\begin{table}
  \input{tab/random_testu01_bigcrush_p}%
  \caption{\testu BigCrush results (parallel)}
  \label{tab:TestU01 BigCrush results (parallel)}
\end{table}
