% ============================================================================
%  MCKL/manual/tex/resample.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2017, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Resampling}
\label{chap:Resampling}

Given a particle system $S_{1:N}$, where $S_i = (X_i,W_i)$ for $i = 1,\dots,N$,
a resampling algorithm generates a new system $\hat{S}_{1:M}$ such that,
\begin{equation*}
  \Exp\Square[Big]{\sum_{i=1}^M{\hat{W}_i\varphi(\hat{X}_i)}} =
  \Exp\Square[Big]{\sum_{i=1}^N{W_i\varphi(X_i)}},
\end{equation*}
for test function $\varphi$. Regardless of other statistical properties, in
practice, such an algorithm can be decomposed into three steps,
\begin{enumerate}
  \item Generate an $N$-vector of replication numbers $r_{1:N}$, such that
    $\sum_{i=1}^N r_i = M$, and $0 \le r_i \le M$ for $i=1,\dots,N$.
  \item Generate an $M$-vector of indices $a_{1:M}$ such that $\sum_{j=1}^M
    \bbI_{\Curly{i}}(a_j) = r_i$, and $1 \le a_i \le N$ for $i = 1,\dots,M$.
  \item Set $\hat{X}_i = X_{a_i}$ and $\hat{W}_i = 1 / M$ for $i = 1,\dots,M$.
\end{enumerate}
Given the results of the first step, the second step can be implemented with a
deterministic algorithm. And the final results are determined up to
re-ordering. Therefore, it is the first step that determines the statistical
properties of the new particle system.

\section{Using resampling with sampler}
\label{sec:Using resampling with sampler}

Recall that any object that is convertible to,
\begin{verbatim}
using eval_type = std::function<void(size_t, Particle<T> &)>;
\end{verbatim}
can be added as a resampling evaluation object to a |Sampler| object. \mckl
defines the following class template,
\begin{verbatim}
template <typename T>
class ResampleEval;
\end{verbatim}
that is compatible with the type above. It has a single constructor,
\begin{verbatim}
explicit ResampleEval(const eval_type &eval);
\end{verbatim}
where |eval_type| is defined as the following,
\begin{verbatim}
using eval_type = std::function<void(size_t, size_t,
    typename Particle<T>::rng_type &, const double *,
    typename Particle<T>::size_type *)>;
\end{verbatim}
An evaluation object that is convertible to the above is used to generate the
$N$-vector of replication numbers $r_{1:N}$. When called, the following
arguments are passed to it,
\begin{verbatim}
eval(N, M, rng, w, r);
\end{verbatim}
where $N$ is the original sample size, $M$ is the new sample size, |rng| is an
\rng engine, |w| is a pointer to the $N$-vector of normalized weights, and
output parameter |r| points to the $N$-vector of replication numbers. One can
define function templates to avoid declaring these parameter types explicitly.
An object of the class |ResampleEval| is convertible to |eval_type| of
|Sampler|, and can be added to a sampler as a resampling evaluation object. Its
operator calls the object passed to its constructor to generate the $N$-vector
of replication numbers $r_{1:N}$. And it generates the $M$-vector of indices
$a_{1:M}$. And last, it uses the |select| method of type |T| to duplicate
states. The vector of indices generated by this operator has the following
property, in addition to those stated earlier at the beginning of this chapter,
\begin{equation*}
  a_i = i \quad \text{if} \quad  r_i > 0 \quad
  \text{for } i = 1,\dots,\min\Curly{N, M}
\end{equation*}
In fact, the |select| method of |StateMatrix| in section~\ref{sec:State} makes
the assumptions of this property about its input indices.

\section{Algorithm}
\label{sec:Algorithm (Resample)}

\mckl implements all algorithms discussed in~\cite{Douc:2005wa} and two
extensions to the those algorithms. Samplers can be constructed with builtin
algorithms as seen in section~\ref{sec:Sampler}. Builtin algorithms are
implemented in the following class template,
\begin{verbatim}
template <typename U01SeqType, bool Residual>
class ResampleAlgorithm;
\end{verbatim}
We explain the template parameters later. This class has the following
interface,
\begin{verbatim}
template <typename RNGType, typename InputIter, typename OutputIter>
void eval(size_t N, size_t M, RNGType &rng, InputIter w, OutputIter r) const
\end{verbatim}
Its parameters are as those described earlier for |eval_type| of
|ResampleEval|. The algorithm that it implements depends on the template
parameters of the class. The type |U01SeqType| shall be a class type with a
default constructor and a call operator. It shall be able to be used as the
following,
\begin{verbatim}
typename std::iterator_traits<IntputIter>::value_type *u;
// allocate space for u
U01SeqType u01seq;
u01seq(rng, R, u);
\end{verbatim}
After the call, it shall generate a sequence $0 \le U_1 \le \dots\le U_R < 1$.
\mckl provides three implementations, which is discussed in the next section.
The algorithm proceeds as the following to generate $r_{1:N}$,
\halfskip
\begin{algorithmic}
  \REQUIRE $\sum_{i=1}^N W_i = 1$
  \IF{\texttt{Residual} is false}
  \STATE $r_i \leftarrow 0$ for $i = 1,\dots,N$
  \STATE $R \leftarrow M$
  \ELSE
  \STATE $r_i \leftarrow \Floor{MW_i}$ for $i = 1,\dots,N$
  \STATE $R \leftarrow M - \sum_{i=1}^N r_i$
  \STATE $W_i \leftarrow MW_i - r_i$ for $i = 1,\dots,N$
  \STATE $W_i \leftarrow W_i / \sum_{i=1}^NW_i$
  \ENDIF
  \STATE Generate $U_{1:R}$ using |U01SeqType|
  \STATE $V_0 \leftarrow 0$, $V_i \leftarrow V_{i - 1} + W_i$ for $i =
  1,\dots,N$.
  \STATE $r_i \leftarrow r_i + \sum_{j=1}^R\bbI_{[V_{i-1},V_i)}(U_j)$
\end{algorithmic}
\halfskip
Builtin schemes differ in their choices of the template parameters |U01SeqType|
and |Residual|. There are three implementations in \mckl of the uniform
sequence,
\begin{verbatim}
class U01SequenceSorted;
\end{verbatim}
generates the sequence $U_{1:R}$ such that it has the same distribution as a
sorted sequence of i.i.d.\ standard uniform random variables $V_{1:R}$.
\begin{verbatim}
class U01SequenceStratified;
\end{verbatim}
generates the sequence $U_{1:R}$ such that $U_i = (i - 1)\delta + V_i\delta$
where $V_{1:R}$ are i.i.d.\ standard uniform random variables and $\delta = 1 /
R$.
\begin{verbatim}
class U01SequenceSystematic;
\end{verbatim}
generates the sequence $U_{1:R}$ such that $U_i = (i - 1)\delta + V\delta$
where $V$ is a standard uniform random variable and $\delta = 1 / R$.

All the builtin algorithms are defined as convenient type aliases,
\begin{verbatim}
using ResampleMultinomial        = ResampleAlgorithm<U01SequenceSorted, false>;
using ResampleStratified         = ResampleAlgorithm<U01SequenceStratified, false>;
using ResampleSystematic         = ResampleAlgorithm<U01SequenceSystematic, false>;
using ResampleResidual           = ResampleAlgorithm<U01SequenceSorted, true>;
using ResampleResidualStratified = ResampleAlgorithm<U01SequenceStratified, true>;
using ResampleResidualSystematic = ResampleAlgorithm<U01SequenceSystematic, true>;
\end{verbatim}
